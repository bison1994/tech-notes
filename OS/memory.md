# 虚拟地址

由操作系统提供虚拟地址到物理地址的映射，由 CPU 中的 MMU 单元（内存管理单元）提供虚拟地址到物理地址的翻译

VMA：虚拟内存区域，隶属于进程的一个数据结构，每一个 VMA 保存某一个段在虚拟空间和可执行文件之间的映射关系

【装载】的过程，核心就是建立 VMA，随后才是可执行文件真正加载到内存的过程，这个过程是通过【页错误】的机制实现的，因为 PC 指向可执行文件入口地址时，所有的指令都还没有实际加载到内存，因此访问虚拟地址，MMU 会发现这个地址在物理内存中没有对应的映射，于是报出【页错误】，随后操作系统再指挥 CPU 根据 VMA 将可执行文件中相应的段分配到物理页面，然后建立虚拟页和物理页的映射，最后再重新回到入口地址，此时就能正常执行了

# 分段

地址（段号 + 偏移） => 段表 => 段的物理基址 + 偏移 => 实际的物理地址

内存的分段是和程序的分段保持一致的，单个段是连续的，多个段是离散的，段的大小不固定，会导致内存分配出现外部碎片，空间利用率低


# 分页

地址（页号 + 偏移） => 页表 => 页的物理基址 + 偏移 => 实际的物理地址

将内存细分为固定大小（常见的大小是 4KB）的单元：页，每个程序离散的映射到多个页。由于程序大小不一定是页的整数倍，所以会出现内部碎片

一个页是 4KB，由于内存的最小单元是字节，即一个页有 4096 个字节，因此一个虚拟地址只需其中的 12 位即可标识偏移量，其他的位则用于寻找页

页表是按照多个层级组织的，因为理论上每一个虚拟地址都需要映射，如果页表只有单个层级，则 64 位地址，除最后 12 位，需要 2^52 个页表项，每个页表项存一个物理页的基址，总大小为 2^52 * 64 = 2^58 个 bit = 2^55 个字节 = 2^45 KB = 2^35 MB = 2^25 GB


# 换页

虚拟页与物理页的映射是按需建立的，操作系统通过【缺页异常】感知需求的发生，然后实际分配物理内存。当物理内存不够时，通过【换页】，解除一部分页所占用的物理内存并重新分配给当前需要的虚拟页。这种机制使得计算机能够利用的内存超出了物理容量的限制


# linux 内存布局

虚拟地址空间，意味着每一个进程看到的都是这样一个图景：32 位地址空间中，有 1GB 是内核空间，剩余 3GB 都是自己的，每个进程根本感知不到、也无需关心、也不认为内存里还有其他进程存在

[](https://courses.engr.illinois.edu/cs225/sp2021/assets/notes/stack_heap_memory/memory_layout.png)

【五个基本段】每个进程看到的“独立”的地址空间都由以下部分组成：

Text Segment：代码
Data Segment：全局变量
BSS Segment：未初始化的全局变量

以上三个部分在虚拟地址空间里是连续紧挨着的，因为其大小是固定不变的

Stack：存储函数调用过程中的局部变量，包括参数。其空间的分配与释放是自动的
Heap：存储不定大小的数据，其空间的分配与释放不是自动的，而是由程序决定的

这两个部分是动态变化的，Stack 从上到下增长，Heap 从下到上增长，目的是避免碰撞，更有效的利用空间，它们的起始位置是随机的，目的是保障安全

但 3GB 空间还是有可能发生“碰撞”的，在现代操作系统中，栈的大小是通常是有限的，超过限定会报栈溢出，而堆的空间分配操作（malloc）导致地址空间增长越界到栈空间，分配操作会返回一个值表示分配出错

栈：一旦函数返回，栈内保存的局部变量就完全释放了，随时可能被其他数据覆盖。因此一个常见的错误是，函数返回了一个指针，而这个指针指向的是栈中的地址

堆：如果不被释放，空间将一直被占据，相对于栈的易失性、临时性，堆具有一种持久性，适合保存需要持久化的数据

> [illinois.edu CS 225: Stack and Heap Memory](https://courses.engr.illinois.edu/cs225/sp2021/resources/stack-heap/)

> [堆和栈的详细比较](https://www.guru99.com/stack-vs-heap.html#3)