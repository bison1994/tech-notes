### Java 技术体系全景

- Java 程序语言
- Java 虚拟机
- Class 文件格式/规范
- Java 官方类库
- Java 官方工具集
- Java 社区类库

JRE：支持 Java 运行标准依赖环境，包括：虚拟机 + 官方类库
JDK：支持 Java 程序开发的最小环境，包括：JRE + Java 语言 + Java 官方工具集

Java 虚拟机是一种通用的、中立的实现，**可支持多种语言**，如 kotlin、Clojure 等。它有独立的规范，是 Java 适配了虚拟机规范，而不是虚拟机规范适配了 Java

这套独立规范的基础，是一种关于数据存储格式的规范，也即**字节码规范**或 **class 文件规范**。任何语言只要能编译成符合规范的格式，就能被虚拟机执行

虚拟机族

- 第一代虚拟机：Classic VM（已废弃）
- 通用虚拟机：HotSpot（最正统、使用最广）、JRockit、IBM J9
- 移动设备、嵌入式设备虚拟机
- 专用虚拟机
- 特定领域虚拟机


### 内存模型 JMM

- 内存划分（运行时数据区）
  - 线程隔离的区域（随线程而生，随线程而灭，一般不考虑垃圾自动回收的问题）
    - **计数器**：每条线程都需要有一个独立的程序计数器
    - **(虚拟机)栈**：每个方法调用时，jvm 对应创建并 push 一个栈帧（Stack Frame），栈帧用于存储局部变量、reference 引用等信息
      - StackOverflowError
    - **本地方法栈**：Native 方法使用的栈
  - 线程共享的区域
    - **方法区**：存储常量、静态变量等“偏静态”的信息，别名 `Non-Heap`，一般不需要垃圾回收，或者说垃圾回收的 ROI 一般不高
      - Runtime Constant Pool：用于存放编译期生成的各种**字面量**与**符号引用**
    - **堆**：此内存区域的唯一目的就是存放对象实例，“几乎”所有对象实例都在这里，堆也是垃圾收集器所管理的主要区域。对象的内存分为三块：
      - **对象头（Header）**：存储哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁...
      - **实例数据（Instance Data）**：程序代码里面所定义的各种类型的字段内容
      - 对齐填充（Padding）：仅用于凑够 8 字节整数倍的空间

- 对象创建过程
  - 1 从常量池检查对应 class 的符号引用，确定其是否已被加载
  - 2 执行类加载
  - 3 为对象分配内存（对象所需内存的大小在类加载完成后便可完全确定）
    - 设置 Object Header，并将其他内存区域初始化为零
  - 4 执行构造函数（即 Class 文件中的 `<init>()` 方法）


### 垃圾回收 GC

- 如何确定哪些对象该被回收（判断对象是否存活、是否仍有被使用）
  - 引用计数：Java 并未使用，主要是存在循环引用等需要额外处理的情形
  - 可达性分析（追踪式垃圾收集）：与 GC Roots 根对象不连通的对象，就是需要被回收的对象
  - 引用分类：为更全的垃圾回收，引用被拓展为四类：强引用、软引用（SoftReference，在系统将要发生内存溢出异常前进行回收）、弱引用（WeakReference，下一次 GC 时就会被回收）、虚引用（PhantomReference，为一个对象设置虚引用的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知）
    - 引用的定义：变量存储的值是一块内存的起始地址
- 何时执行收集：一般是在内存不够用时执行，用户可调用 `System.gc()` 主动触发 GC
- 怎样执行收集
  - 分代：早期的垃圾收集器主要基于**分代收集理论**设计
    - 分代理论的**经验**假设：
      - 多数对象都是朝生夕灭的
      - 熬过越多次垃圾回收的对象越难以被回收（熬过次数即**年龄**）
      - 跨代引用相对于同代引用来说仅占极少数
    - 一般将堆划分成两部分：新生代、老年代
  - 标记-清除（Mark-Sweep）：先标记，再统一清除，主要问题是一次性清除大量对象的执行效率低，且会产生大量**内存碎片（fragment）**
    - **由于内存操作极为频繁，碎片问题对性能影响很大，这是关键决策点**
  - 标记-复制：将内存均分为二，只用一半进行分配，每次 GC 时，将存活对象依次复制到另一半，剩余直接清除，好处是没有内存碎片，缺点是存活对象越多，复制开销越大，且可用内存减半
    - 当前主流 JVM 采用该策略用于新生代 GC，且内存并非按 1：1 划分。老年代由于存活对象占多数，所以一般不使用该策略
  - 标记-整理（Mark-Compact）：将存活对象向内存空间的一端移动，然后直接清理掉边界以外的内存。问题是移动操作，需要暂停整个应用程序，带来性能损耗，需要权衡解决碎片问题带来的性能提升，能否抵消移动操作的损耗，例如当内存碎片影响不大时，就直接用标记-清除，直到碎片达到临界值，再改用标记-整理
- 垃圾收集器的三项最重要的指标是：内存占用（Footprint）、吞吐量（Throughput）和延迟（Latency），三者共同构成了一个“不可能三角”


> 参考材料：《深入理解 Java 虚拟机》
