# 并发

并发有两个主题：
- 如何正确的实现各类并发任务场景（例如服务器接受请求）
- 如何正确的实现线程安全性


### 实现并发的相关 API

- 1 线程 `Thread` 类
- 2 内置锁 `sychronized`，可修饰方法、代码块。一种互斥锁，将一段代码原子化（临界区 critical section）
    - 每个 Java 对象都内置了一个锁，继承了 Object 的 `wait`、`notify`、`notifyAll` 方法
- 3 `volatile`。Java 5.0 以前只有 `synchronized`（“内置锁”，jvm 内置属性） 和 `volatile`
- 4 `java.util.concurrent` 包（简称 `JUC`）
    - locks 包：ReentrantLock、Condition、Lock、ReadWriteLock...
      - 互斥锁 VS 读写锁 ReadWriteLock：写是互斥的，读不互斥，目的是提高并行性能，是对互斥锁的优化
      - Java 5.0 新增 `ReentrantLock`（“显式锁”），和 synchronized 很相似，主要是提供更多的灵活性，包括用于自定义轮询锁和定时锁以应对死锁问题、支持自定义释放锁的时机（unlock 方法）、支持中断（lockInterruptibly 方法）、支持调整加锁的代码范围、支持定义锁的公平性
      - `AbstractQueuedSynchronizer`：多数同步类的基类
    - Synchronizers 同步相关的类
      - Semaphore 类，信号量
      - Latch 类，闭锁
      - CyclicBarrier 类，栅栏
      - Phaser
      - Exchanger
    - 调度相关的类，如 Executors 类、ThreadPoolExecutor 类...
    - Queues 队列相关的类
    - Timing 计时相关的类
    - Concurrent Collections 并发容器
    - Future、Runnable、Callable
    - ...


### 线程

- 线程 6 种状态
  - 阻塞：请求一个未释放的锁，则进入被阻塞状态
  - 等待：wait 某种条件出现
  - 计时等待：等待的一种特例，超时则不再等待
  - 终止：只有两种情况，一是方法执行完自然终止，二是异常终止
- 线程的属性
  - 中断状态
    - 检查是否中断：isInterrupted
    - 从外部主动中断一个线程：interrupt
  - 设置线程名
  - 设置未捕获异常的处理器
  - 设置优先级（最好不要用，实际优先级高度依赖于宿主系统）
  - **守护线程**
    - 为什么需要守护线程：因为有一类程序，特点是作为某种服务需要单独在一个线程里一直独立运行到其他程序全部结束，由于 Java 中无法直接关闭一个线程，因此这个程序一旦启动，如果不手动设置关闭逻辑，将导致 jvm 无法退出。守护线程就是为了此种场景而设计，所谓守护，其实就是无限循环但不阻塞 jvm 退出，当 jvm 退出后，守护线程自然销毁
    - jvm 启动时，除了主线程是普通线程，其他线程都是守护线程。派生的线程会继承创建者所在线程的守护属性
    - jvm 在所有非守护线程结束后，自动退出
    - 守护线程运行的程序应该随时可以退出，而不产生副作用


### 线程安全性

线程安全定义：并发环境下，无论执行何种操作、无论操作以何种时序执行，类始终表现正确

**线程不安全，本质是两类问题**

- **竞态问题**（race condition）：由于不稳定的执行顺序导致不正确的结果
  - 【单个操作粒度】
    - 最简单更改操作，在指令层面至少也分为“读”-“改”-“写”三个步骤
    - “先 check 再 act” 也是一种存在竞态问题的典型场景 -> 依赖先验条件，而条件是非线程安全的 -> 导致基于可能失效的观察结果作出执行
  - 【多个操作粒度】
    - 一个方法内的复合操作，受中断、重排序等影响，执行顺序是不稳定的
    - 多个方法，例如：一个对象被两个线程共享，一个线程调用对象的 a 方法，另一个线程调用对象的 b 方法，a 和 b 方法如果涉及对状态的读写，即便状态是对象私有的，也可能会出问题
- **可见性问题**（visibility），本质是说共享变量被一个线程修改，其他线程能符合预期的获得正确的值。可认为是“读”场景的竞态问题
- 以上两类问题本质原因是存在共享（shared）和可变（Mutable）状态被并发的**修改**
  - 一种线程不安全的情形：引用对象逃逸（Escape）到了多线程环境中


**实现线程安全的难点**

- 问题的出现是概率性的，事前难以测出来，事后难以复现
- 同步带来额外的问题
  - 性能问题：并发本质是为了提效，同步相当于牺牲一部分效率来换取安全性
    - 应该只对需要同步的代码加锁，即最小范围加锁
    - 不要重复加锁，例如在同步块内就没必要用原子类
    - 对于长时间执行的计算或者长时间等待的场景，要避免加锁
  - 活跃性问题（Liveness）
    - 死锁：全称应该叫“锁顺序死锁”
    - 活锁：与死锁类似，程序都无法进一步执行，但区别在于，死锁情况下，程序都在“干等”，活锁情况下，程序都在“无限重复的响应对方”
    - 饥饿 Starvation：程序一直无法获得请求的资源，可能是因为资源一直被占用，也可能因调度优先级关系所致


**实现线程安全的机制**

- 将共享改为非共享
- 将可变改为不可变（immutable、“纯函数”），如使用 final
- 使用同步/互斥：将“复合”操作改为原子操作。
  - 对单个操作加锁
  - 对多个操作（代码块）加锁
- 不使用并发
  - 破坏虚拟机/操作系统实现并发的机制、为了优化但引入并发问题的机制（多核、中断、重排序...）
    - **volatile**：告诉编译器和运行时，不要做重排序一类的优化，以确保变量具备可见性（比 sychronized 更轻量的同步机制，因为不涉及加锁操作），但不保障原子性
  - 按需使用多线程，哪些部分（尤其是写入操作）能用单线程，就不要用多线程
- 线程封闭（Thread Confinement）：解决对象 Escape 导致的线程安全隐患，如对状态进行封装、用 ThreadLocal 实现封闭
  - 一种相关的支持高效且安全并发的设计模式：阻塞队列 + 生产者/消费者模式

> 锁意味着性能的损失，能通过别的机制解决，就不要无脑加锁，结合场景综合运用各类线程安全机制。线程安全和高性能之间具有矛盾性

> 不存在共享与可变状态的**无状态对象**一定是线程安全的


### 锁

- 锁：用于保护一个代码片段，被保护的代码片段在任意时刻只能由一个线程执行
- 锁，可理解为“锁定”，即排他性独占。“获取 xx 的锁”可翻译为“锁定 xx”
- 三类同步方式（按优先级排序）：
  - 使用 `java.util.concurrent` 包
  - 内置锁 `sychronized`
  - 【显式】使用 `Lock` 或 `Condition`（内置的条件队列）
- 对操作加锁，要明确用的谁的锁。不同方法如果用的不是同一个锁，这些方法同时被调用时，是不保证原子性的

锁的性质：
- 是否公平（fair）：是按照请求时序排队获得锁，还是可“插队”获得锁（非公平），存在非公平的原因是性能更好，因为要保证公平，需要某种算法实现。相比于让队列中处于挂起状态的线程，通过恢复状态再分配锁，直接给请求锁的运行态的线程分配锁，性能更高。公平与否一般不会影响程序运行的效果
  - 公平锁：ReentrantLock(true)
  - 非公平锁：Synchronized、ReentrantLock(false)
- 是否可重入（reentrant，又名递归锁）：同一个线程内，调用多个加锁的方法，请求属于线程自身的锁，不会产生阻塞
- 是否独享：
  - 独享锁的同义词：互斥锁
  - 共享锁的具体代表：读写锁
- 是否需要加锁
  - 悲观锁
  - 乐观锁（无锁编程）
- 锁的获取难度/开销
  - 偏向锁
  - 轻量级锁
  - 重量级锁


### 死锁

- jvm 无法解决死锁，一旦出现死锁，就会卡死，只能重启
- 四个条件：不可共享、不可抢占、持有且不释放、循环等待
  - Lock-Ordering DeadLock： 死锁的关键原因是循环等待。导致循环等待的原因，是不同线程以不同顺序加锁。
    - 容易发现的情况：从代码加锁顺序看出不一致
    - 不容易发现的情况：代码层面加锁顺序看似一致，但运行时执行产生不一致
      - 传参导致加锁顺序不一致，例如 a 转账给 b 和 b 转账给 a 同时发生
      - 协同对象间方法执行顺序不一致，导致加锁不一致
- 避免死锁：基本思路是破坏四个条件
  - 如果可以，每个程序一次最多只获得一个锁
  - 定时锁：给锁增加超时设置
  - 轮询锁：发现不能同时获得两个锁，就释放已有的锁，再重新请求锁
- 诊断/检测：利用 jvm 的 Thread dump 功能


### 线程池

- 线程池最佳适用场景：一组同类型的、相互独立的任务
- 线程池的大小：如果过大，则发生资源竞争；如果过小，则影响吞吐量
- 创建线程的基本参数：基本大小（core size）、最大大小、存活时间（单个线程最大的空闲时间，超出则被销毁）。基本大小和最大大小相等，则表明是固定线程池，否则就是动态线程池
  - newFixedThreadPool：线程不会超时
  - newCachedThreadPool：基本大小为 0，最大大小为无穷，超时时间为 1min。适合相互有依赖的任务，避免饥饿
- 任务到达超过了线程池的处理上限，线程池怎么处理？用队列保存等待任务
  - 无界队列（有固定大小的队列）
  - 有界队列：满了怎么办？-> 饱和策略
    - 中止 Abort：直接抛异常
    - 抛弃
      - Discard：直接抛弃新任务
      - Discard Oldest：抛弃队列中下一个即将被执行的任务，用于置换新任务
    - Caller Runs：Executes the task in the caller’s thread
  - 同步移交（Synchronous Handoff）：在一定条件下，新任务直接移交给刚完成上一个任务的线程，无需先进队列再分配到线程
- 可自定义创建线程的工厂方法
- “勾子方法”：beforeExecute、afterExecute、terminated

> 官方文档：https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html


————————————————————————————————————————————————————————

> 参考书：《Java 并发编程实战》