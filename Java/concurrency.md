# 并发

### 线程

- 线程 6 种状态
  - 阻塞：请求一个未释放的锁，则进入被阻塞状态
  - 等待：wait 某种条件出现
  - 计时等待：等待的一种特例，超时则不再等待
  - 终止：只有两种情况，一是方法执行完自然终止，二是异常终止
- 线程的属性
  - 中断状态
    - 检查是否中断：isInterrupted
    - 从外部主动中断一个线程：interrupt
  - 设置为守护线程
  - 设置线程名
  - 设置未捕获异常的处理器
  - 设置优先级（目前不要用，实际优先级高度依赖于宿主系统）
- 锁：用于保护一个代码片段，被保护的代码片段在任意时刻只能由一个线程执行
- 三种加锁的方式（按优先级排序）：
  - 使用预定的 java.util.concurrent 包
  - 内置锁 sychronized，可修饰方法、代码块。一种互斥锁，将一段代码原子化（临界区 critical section）
    - 每个 Java 对象都内置了一个锁
  - 使用 Lock 或 Condition
- volatile：告诉编译器和运行时，不要做重排序一类的优化，以确保变量具备可见性（比 sychronized 更轻量的同步机制，因为不涉及加锁操作），但不保障原子性


### 线程安全性

线程安全定义：并发环境下，无论以何种时序执行，类始终表现正确

线程不安全，本质是两类问题：
- **竞态问题**（race condition）
- **可见性问题**（visibility），本质是说共享变量被一个线程修改，其他线程能符合预期的获得正确的值

实现线程安全的难点：问题的出现是概率性的、难以复现的

应对线程安全，本质是对共享（shared）和可变（Mutable）状态的管理。

四类解决机制：
- 将共享改为非共享
- 将可变改为不可变
- 使用同步
  - 将“复合”操作改为原子操作
- 从根源解决：破坏虚拟机、操作系统实现并发的机制（多核、中断、重排序...）

不存在共享与可变状态的无状态对象一定是线程安全的

竞态条件：由于不稳定的执行顺序导致不正确的结果
- 【单个操作粒度】
  - 最简单更改操作，在指令层面至少也分为“读”-“改”-“写”三个步骤
  - “先 check 再 act” 也是一种存在竞态问题的典型场景 -> 基于可能失效的观察结果作出执行
- 【多个操作粒度】需要对整个代码块加锁

同步带来的问题
- 性能问题：并发本质是为了提效，同步相当于牺牲一部分效率来换取安全性
  - 应该只对需要同步的代码加锁，即最小范围加锁
  - 不要重复加锁，例如在同步块内就没必要用原子类
  - 对于长时间执行的计算或者长时间等待的场景，要避免加锁
- 活跃性问题（Liveness）：死锁、活锁、饥饿


### 锁的性质

- 是否公平（fair）：
  - 公平锁：ReentrantLock(true)
  - 非公平锁：Synchronized、ReentrantLock(false)
- 是否可重入（reentrant，又名递归锁）：同一个线程内，调用多个加锁的方法，请求属于线程自身的锁，不会产生阻塞
- 是否独享：
  - 独享锁的同义词：互斥锁
  - 共享锁的具体代表：读写锁
- 是否需要加锁
  - 悲观锁
  - 乐观锁（无锁编程）
- 锁的获取难度/开销
  - 偏向锁
  - 轻量级锁
  - 重量级锁

### 锁的实现机制

分段锁

AQS

自旋锁

CAS，Compare and Swap



> 参考书：《Java 并发编程实战》