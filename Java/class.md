### 数据类型

- 8 种基本类型：4 种整型、2 种浮点型、1 种字符型、1 种布尔型
- 没有字符串类型，但有**预定义**的字符串类，不需要 new，只要是双引号括起来的，都是字符串类的一个实例对象，因而可以直接在字符串上调用实例方法
- 字符串是 immutable 的
- 由于字符串是实例对象，因此不能用 == 来检测相等性
- 强制类型转换：`double a = 1.0; int b = (int) a;`
- 对象包装器与自动装箱：基本类型对应的类即对象包装器，自动装箱就是自动将基本类型转化为对应类的对象，例如：`var ls = new ArrayList<Integer>(); ls.add(3);`

### 数组

- 声明方法：`Class[] cls = new Class[n]`
- 数组大小一旦确定就不能变
  - 对比：C/C++ 要求编译时就确定数组大小，Java 允许运行时确定数组大小，但一样的是数组大小一旦确定就不能变

### 集合类

- 一元集合：列表 List、去重集合 Set、队列 Queue
- 二元映射集合：Map
- 集合的镜映：视图 View

> 通用问题：大小是否可伸缩？是否允许重复？是否有序？是否可更改？

- ArrayList：自适应大小，解决数组大小不可改的问题
- LinkedList：通过链表解决 ArrayList 插入删除效率缓慢的问题
- HashSet：无重复的无序散列集合，解决 List 查询缓慢的问题。基于链表 or 平衡二叉树实现
  - LinkedHashSet：有序的无重复散列集合。可记住元素插入次序的集
- TreeSet：无重复的有序集合，解决添加数据时查重效率问题。基于红黑树实现
- EnumSet：有限个实例的 Set
- ArrayDeque：双端队列
- PriorityDeque：适用于随机添加，但每次都取出最优先任务的场景
- HashMap：映射。储存键值对的数据结构
  - WeakHashMap：方便垃圾回收的 HashMap
  - LinkedHashMap：按序添加的 HashMap
  - EnumMap：键为 EnumSet 的 Map
  - IdentityHashMap：适用于跟踪哪些对象已被遍历过的场景
- TreeMap：键有序的 Map


### 类

- Java 以类作为构建程序的基础单位，**Java 程序的全部内容，都必须放在类中**。在运行时，虚拟机会为每一个类维护一个标识，并通过一种泛型类 Class 暴露给程序
  - 一个文件可以有多个类，但最多只能有零个或一个公共类
    - 如果有公共类，文件名必须与公共类的名称一致
    - 如果没有公共类，文件名可以是任意的
  - 编译后，无论一个 .java 文件中有多少个类，每一个类都会输出到单独一个 .class 文件（名称同类名，与原文件名无关），虚拟机会为每一个类维护独一的 Class 类
- 编程范式
    - 过程式编程：先考虑实现算法，再考虑数据结构
    - 面向对象编程：先建模，识别与设计数据结构（类、实体），再考虑方法实现
- 最简单的两种类：
  - pojo
  - 完全由静态属性和静态方法构成的类
- 类的组成
  - 属性字段（field）
  - 方法
    - mutator method
    - accessor method
    - ...
  - main
    - Java 应用程序必须至少有一个 main 方法作为程序运行的入口
  - 构造函数（构造器）
    - 与类名相同的方法，就是构造器
    - `new Date` 中的 `Date` 不是类，而是类的构造器
    - 不能当作方法调用，只能用 `new` 或者 `this()` 或者 `super()` 调用，不需要也没有返回值
    - 仅当没有定义构造器时，Java 才会默认补上一个无参构造器
    - 继承场景下，只要父类定义了有参构造器，那么子类就必须调用父类的构造器
  - 初始化块
    - 非必要机制（替代方案是将代码写在构造器里），因此最好不用
- 封装：一种屏蔽机制，由此确保内部的改动对外部不可见、无感，对外提供依赖时，内部迭代可以预期不会影响外部，因为外部不依赖私有方法或字段


### 包 package

- 包：类的集合，可以是应用（如安卓应用的包名），也可以是依赖包
- 设计包的目的是确保类名的唯一性，一般在引入外部依赖时会有这个问题
  - 包名如何确保唯一性？例如可借助域名的唯一性来保障
- 包名必须与目录路径一致，否则在执行时，类的寻址会出问题（编译不报错，执行报错）
- 为避免用户在 Java 预定义的包里添加类（用户在相应目录添加自定义的类，类指定 package 为某个预定义的包 java.xxx），从而对预定义类进行修改，类加载器拒绝加载用户定义的 java 开头的包里的类
- 静态导入：只导入静态字段或静态方法
- 没定义包，那么类就属于无名包


### 方法

- 【组成】方法名、参数列表、函数体、修饰符、返回类型、异常声明
  - 非静态方法拥有隐式参数： `this`
  - 不定参数数量的声明方式：`fn(Object... args)`
  - 指向父类的关键字：`super`
- 【传参】是按值调用（call by value）
  - 程序语言区分按值调用、按引用调用，区别是传入变量副本（按值调用），还是传入变量本身（按引用调用）
  - 如果传入的变量 x 是引用类型，那么具体过程是：变量 x 的“指针”被 copy 了一份后传入函数，由于 copy 指向的还是那个对象，因此函数内可以修改对象，但无法影响 x
- 【签名】方法的唯一性由签名（方法名 + 参数类型）保证，签名相同，哪怕一个 static 一个非 static 也是不能共存的
  - 返回值类型与签名无关
- 【重载】名称一样而签名不一样的方法，则构成重载 `overloading`。同一个类里的【同名方法】或【同名构造器】被调用时，编译器如何定位哪个方法或构造器的机制
  - 任何方法都可以被重载，构造器也可以
- 【覆盖】继承场景下，子类和父类出现【同名字段】或【同签名方法】时，Java 所设计的约束条件，子类中的方法与字段，要么定义上有差异，要么接受覆盖机制约束
  - 方法不能被 modified，只能被 `override`（更准确的说，是被遮蔽，遮蔽效果是方法调用时虚拟机的寻址规则决定的。子类的属性也会遮蔽同名的父类属性）
  - Java 没有方法指针，不能将方法作为一种引用对象，进行赋值或调用的操作
  - 要想脱离对象，直接调用某个方法，需借助反射，变相的实现方法指针
- 【调用】当调用某方法 f 时，大致过程如下：
  - 编译器找到子类和父类所有可访问的同名方法
  - 找到签名匹配的方法（重载解析）
  - 优先选取子类方法（覆盖）
  - 对于 private 方法、static 方法、final 方法和构造器，可以在编译时就知道是哪个方法（静态绑定）
  - 否则在运行时寻找目标方法（动态绑定，支撑多态性的语言机制）
  - 虚拟机会为每个类预先生成一个方法表，每次调用某对象的方法，就直接查表
- 【对比】方法和构造函数的区别
  - 命名规则
  - 执行时机
  - 方法必须有返回值，构造函数没有返回值（与类同名的函数，如果定义了返回类型就是方法，没有定义返回类型就是构造函数）
  - 构造函数不能被 override


### 多态

- 多态，是针对赋值为实例对象的**变量**而言的。具体是指这个变量可以被赋值为不同类的实例，只要这些类属于同一大类（共同的父类）
  - “类型软约束”，让强类型语言也有一定的动态化能力从而更具灵活性
- 实现多态的语言机制，是动态绑定
- `泛型`是多态的代表体现


### 继承

- 继承是一种类的拓展机制
- 类与类可以构成单链继承关系，最多只能继承一个类（不允许多重继承），编译时会检测循环继承并报错
- 所有类的超类：`Object`，每个类都默认继承了 Object 类
- 父类更抽象、子类更具体
- 通过 `final` 可以阻止类被继承（声明一个类不支持拓展），或者阻止方法被覆盖（保持语义的一致性，不希望子类篡改）


### 覆盖（overriding）

- 子类的方法只要满足【和父类方法拥有相同签名】这一个条件，就形成了覆盖（`override`）
- 覆盖方法有两个约束
  - 返回类型：只能是父类方法返回类型的同类或子类，否则编译会报错（why？）
  - 访问控制：不能低于父类方法的可见性，否则编译会报错（why？）
- 静态方法或字段，不存在覆盖


### 静态

- 静态字段适合定义常量，静态方法适合做`工厂方法`
- 只有“属性”、“方法”和“初始化块”可以被声明为静态，不能将类声明为静态
- 静态属性和静态方法只属于类，与实例对象完全无关（因而静态方法没有也不能有 this）
  - 可以用实例对象上访问静态属性或调用静态方法，但最好不要这么做
- 构造函数也不能被声明为静态，这没有意义，构造函数仅作用于实例化过程，和静态无关


### 可变性

通过 final 声明不可变性

- 用于属性
  - 必须在构造对象之时或之前初始化
  - 区分“基础类型”和“引用类型”的不可变性
- 用于方法
  - 主要用于避免被子类修改，将方法声明为 final 标识子类不能 override（再次定义）
  - private 和 static 方法，具有隐含的不可变性，加 final 不会报错，不过没必要
- 用于类
  - 主要用于声明该类不可继承


### 访问权限

权限从小到大依次是：
- private：仅在一个类的内部可见
- 默认：对包内的所有的类可见
  - 类可以使用同一个包内的所有类
- protected：在默认权限之上拓展了对所有子类的可见性
  - 由于 protected 向其他的包开了一道口子，可能会被恶意利用，所以一般来说不要用
  - protected 最好用于 abstract 方法，这样 protected 的作用，就相当于只是突破包访问的限制，而不会产生其他副作用
- public：对所有类可见
  - 对于公共类，任何人可以通过继承派生出新类

类及其组成要素能用的访问权限
- 类：top level 的类不能是 private，其他都可以
- 方法 & 属性：
- main：只能是 public
- 构造函数：

> 最佳实践：尽可能使用最小权限


### 抽象类

- 抽象类的设计，是为了实现这样一种效果：某些位于上层的类由于太抽象，它们不应该被实例化，而应该被视为一种`约束`，要求子类必须实现某种动作
- `abstract` 不能用于属性字段，只能用于类和方法
- 只要含有一个抽象方法，该类就必须是抽象类，继承抽象类的子类如果没有实现抽象方法，也必须声明为抽象类
- 因为抽象类不能被实例化，这种机制保证了抽象方法必须被子类实现，否则子类就没法被使用


### 枚举类

### 接口

- 接口只有定义，没有实现。只能有方法的定义，不能有字段的定义，可以有常量
  - 可以提供一种兜底的默认实现，以减轻实现类的编码量，另一个重要用途是解决兼容的问题
- 接口的所有方法，默认都是 public，限定访问是没有意义的，因为接口不关心具体实现，也就不关心访问的限制或隔离
  - 尽管也能定义静态方法和私有方法，但这些长尾特性使用场景很有限
- 对于普通类，接口的所有方法都必须被实现，抽象类则不需要
- 一个类可以 implement 多个接口
- 接口可以被视为一种【类型】，定义变量时可以用接口声明其类型
- 接口之间也可以继承
- 接口的好处：Java 不允许多重继承，以减小复杂度，但接口提供了一种弥补


### lambda 表达式

- 带参数的表达式
  - 参数 -> 单个表达式
  - 参数 -> { 多个表达式 }
- 使用场景
  - 实现只有一个方法的接口


### 编译器寻找类的规则

大致顺序如下：
- Java API 所在目录
- class path 指定的目录
  - 可以执行多个目录，编译器会按顺序找
  - `.` 号表示当前目录，如果没有显式定义 class path，那么 `.` 就是默认 class path
  - 如果显式的定义了 class path，需要手动添加 `.`，否则当前目录就不在 class path 中
