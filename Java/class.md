### 类

- Java 以类作为构建程序的基础单位，Java 程序的全部内容，都必须放在类中。在运行时，虚拟机会为每一个类维护一个标识，并通过一种泛型类 Class 暴露给程序
  - 虚拟机会为每一个类维护独一的 Class 类
- 编程范式
    - 过程式编程：先考虑实现算法，再考虑数据结构
    - 面向对象编程：先建模，识别与设计数据结构（类、实体），再考虑方法实现
- 最简单的两种类：
  - pojo
  - 完全由静态属性和静态方法构成的类
- 类与类可以构成单链继承关系（循环继承编译时会报错）
- 所有类的超类：Object（不妨称之为根类）
- 类的组成
  - 字段
  - 方法
  - main
  - 构造函数
  - 初始化块


### 实例对象

- 多态，是针对赋值为实例对象的**变量**而言的。具体是指这个变量可以被赋值为不同类的实例，只要这些类属于同一大类（共同的父类）
- 实现多态的基础特性，是动态绑定


### 方法

- 方法的组成部分：方法名、参数列表、函数体、修饰符、返回类型、异常声明
- 方法不能被 modified，只能被 override（更准确的说，是被遮蔽，遮蔽效果是方法调用时虚拟机的寻址规则决定的。子类的属性也会遮蔽同名的父类属性）
  - Java 没有方法指针，不能将方法作为一种引用对象，进行赋值或调用的操作
  - 要想脱离对象，直接调用某个方法，需借助反射，变相的实现方法指针
- 方法的唯一性由签名（方法名 + 参数列表）保证，签名相同，哪怕一个 static 一个非 static 也是不能共存的
- 方法和构造函数的区别
  - 命名规则
  - 执行时机
  - 方法必须有返回值，构造函数没有返回值（与类同名的函数，如果定义了返回类型就是方法，没有定义返回类型就是构造函数）
  - 构造函数不能被 override
- 哪怕签名相同，方法和构造函数也是可以同名的，因为调用的方式不一样
- 非静态方法拥有隐式参数：this
- 不定参数数量的声明方式：fn(Object... args)


### 覆盖

- 子类的方法只要满足【和父类方法拥有相同签名】这一个条件，就形成了覆盖（override）
- 覆盖方法有两个约束
  - 返回类型：只能是父类方法返回类型的子集，否则编译会报错 
  - 访问控制：不能低于父类方法的可见性，否则编译会报错


### 静态

- 只有属性与方法可以被声明为静态，不能将类声明为静态
- 静态属性和静态方法与实例完全无关，静态方法没有也不能有 this
- 构造函数也不能被声明为静态，这没有意义，构造函数仅作用于实例化过程，和静态无关


### 可变性

通过 final 声明不可变性

- 对于属性
  - 必须在构造对象之时或之前初始化
  - 区分“基础类型”和“引用类型”的不可变性
- 对于方法
  - 主要用于避免被子类修改，将方法声明为 final 标识子类不能 override（再次定义）
  - private 和 static 方法，具有隐含的不可变性，加 final 不会报错，不过没必要
- 对于类
  - 主要用于声明该类不可继承


### 静态绑定与动态绑定

- final、static、private 方法和构造函数都是静态绑定，在编译期就能明确识别是哪个方法


### 访问权限

- private：仅在一个类的内部可见
- 默认：对包内的所有的类可见
- protected：在默认权限之上拓展了包外子类的可见性
  - 由于 protected 向其他的包开了一道口子，可能会被恶意利用，所以一般来说不要用
  - protected 最好用于 abstract 方法，这样 protected 的作用，就相当于只是突破包访问的限制，而不会产生其他副作用
- public：对所有类可见


### 抽象类

- 抽象类的设计，是为了实现这样一种效果：某些位于上层的类由于太抽象，它们不应该被实例化，而应该被视为一种约束，要求子类必须实现某种动作
- abstract 不能用于属性字段
- 只要含有一个抽象方法，该类就必须是抽象类，继承抽象类的子类如果没有实现抽象方法，也必须声明为抽象类
- 因为抽象类不能被实例化，这种机制保证了抽象方法必须被子类实现，否则子类就没法被使用

> 非正式的讲，抽象类是一种半残的类


### 枚举类

### 接口

- 接口只有定义，没有实现。只能有方法的定义，不能有字段的定义，可以有常量
  - 可以提供一种兜底的默认实现，以减轻实现类的编码量，另一个重要用途是解决兼容的问题
- 接口的所有方法，默认都是 public，限定访问是没有意义的，因为接口不关心具体实现，也就不关心访问的限制或隔离
  - 尽管也能定义静态方法和私有方法，但这些长尾特性使用场景很有限
- 对于普通类，接口的所有方法都必须被实现，抽象类则不需要
- 一个类可以 implement 多个接口
- 接口可以被视为一种【类型】，定义变量时可以用接口声明其类型
- 接口之间也可以继承
- 接口的好处：Java 不允许多重继承，以减小复杂度，但接口提供了一种弥补


### lambda 表达式

- 带参数的表达式
  - 参数 -> 单个表达式
  - 参数 -> { 多个表达式 }
- 使用场景
  - 实现只有一个方法的接口