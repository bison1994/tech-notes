### 数据类型

- 8 种基本类型：4 种整型、2 种浮点型、1 种字符型、1 种布尔型
- 没有字符串类型，但有**预定义**的字符串类，不需要 new，只要是双引号括起来的，都是字符串类的一个实例对象，因而可以直接在字符串上调用实例方法
- 字符串是 immutable 的
- 由于字符串是实例对象，因此不能用 == 来检测相等性

### 类

- Java 以类作为构建程序的基础单位，**Java 程序的全部内容，都必须放在类中**。在运行时，虚拟机会为每一个类维护一个标识，并通过一种泛型类 Class 暴露给程序
  - 一个文件可以有多个类，但最多只能有零个或一个公共类
    - 如果有公共类，文件名必须与公共类的名称一致
    - 如果没有公共类，文件名可以是任意的
  - 编译后，无论一个 .java 文件中有多少个类，每一个类都会输出到单独一个 .class 文件（名称同类名，与原文件名无关），虚拟机会为每一个类维护独一的 Class 类
- 编程范式
    - 过程式编程：先考虑实现算法，再考虑数据结构
    - 面向对象编程：先建模，识别与设计数据结构（类、实体），再考虑方法实现
- 最简单的两种类：
  - pojo
  - 完全由静态属性和静态方法构成的类
- 类与类可以构成单链继承关系，最多只能继承一个类（循环继承编译时会报错）
- 所有类的超类：Object（不妨称之为根类）
- 类的组成
  - 属性字段
  - 方法
    - mutator method
    - accessor method
    - ...
  - main
    - Java 应用程序必须至少有一个 main 方法作为程序运行的入口
  - 构造函数（构造器）
    - `new Date` 中的 `Date` 不是类，而是类的构造器
    - 不能当作方法调用，只能用 `new` 或者 `this()` 调用，不需要也没有返回值
    - 仅当没有定义构造器时，Java 才会默认补上一个无参构造器
  - 初始化块
    - 非必要机制（替代方案是将代码写在构造器里），因此最好不用


### 包 package

- 包：类的集合，可以是应用（如安卓应用的包名），也可以是依赖包
- 设计包的目的是确保类名的唯一性，一般在引入外部依赖时会有这个问题
  - 包名如何确保唯一性？例如可借助域名的唯一性来保障
- 包名必须与目录路径一致，否则在执行时，类的寻址会出问题（编译不报错，执行报错）
- 为避免用户在 Java 预定义的包里添加类（用户在相应目录添加自定义的类，类指定 package 为某个预定义的包 java.xxx），从而对预定义类进行修改，类加载器拒绝加载用户定义的 java 开头的包里的类
- 静态导入：只导入静态字段或静态方法
- 没定义包，那么类就属于无名包


### Jar 包


### 实例对象

- 多态，是针对赋值为实例对象的**变量**而言的。具体是指这个变量可以被赋值为不同类的实例，只要这些类属于同一大类（共同的父类）
- 实现多态的基础特性，是动态绑定


### 方法

- 方法的组成部分：方法名、参数列表、函数体、修饰符、返回类型、异常声明
- 方法传参是按值调用（call by value）
  - 程序语言区分按值调用、按引用调用，区别是传入变量副本（按值调用），还是传入变量本身（按引用调用）
- 方法不能被 modified，只能被 override（更准确的说，是被遮蔽，遮蔽效果是方法调用时虚拟机的寻址规则决定的。子类的属性也会遮蔽同名的父类属性）
  - Java 没有方法指针，不能将方法作为一种引用对象，进行赋值或调用的操作
  - 要想脱离对象，直接调用某个方法，需借助反射，变相的实现方法指针
- 方法的唯一性由签名（方法名 + 参数类型）保证，签名相同，哪怕一个 static 一个非 static 也是不能共存的
  - 返回值类型与签名无关
- 方法和构造函数的区别
  - 命名规则
  - 执行时机
  - 方法必须有返回值，构造函数没有返回值（与类同名的函数，如果定义了返回类型就是方法，没有定义返回类型就是构造函数）
  - 构造函数不能被 override
- 哪怕签名相同，方法和构造函数也是可以同名的，因为调用的方式不一样
- 非静态方法拥有隐式参数：this
- 不定参数数量的声明方式：fn(Object... args)


### 覆盖（overriding）

- 子类的方法只要满足【和父类方法拥有相同签名】这一个条件，就形成了覆盖（override）
- 覆盖方法有两个约束
  - 返回类型：只能是父类方法返回类型的子集，否则编译会报错 
  - 访问控制：不能低于父类方法的可见性，否则编译会报错


### 重载（overloading）

- 特指构造器的“覆盖”机制


### 静态

- 静态字段适合定义常量，静态方法适合做工厂方法
- 只有“属性”、“方法”和“初始化块”可以被声明为静态，不能将类声明为静态
- 静态属性和静态方法只属于类，与实例对象完全无关（因而静态方法没有也不能有 this）
- 构造函数也不能被声明为静态，这没有意义，构造函数仅作用于实例化过程，和静态无关


### 可变性

通过 final 声明不可变性

- 对于属性
  - 必须在构造对象之时或之前初始化
  - 区分“基础类型”和“引用类型”的不可变性
- 对于方法
  - 主要用于避免被子类修改，将方法声明为 final 标识子类不能 override（再次定义）
  - private 和 static 方法，具有隐含的不可变性，加 final 不会报错，不过没必要
- 对于类
  - 主要用于声明该类不可继承


### 静态绑定与动态绑定

- final、static、private 方法和构造函数都是静态绑定，在编译期就能明确识别是哪个方法


### 访问权限

权限从小到大依次是：
- private：仅在一个类的内部可见
- 默认：对包内的所有的类可见
  - 类可以使用同一个包内的所有类
- protected：在默认权限之上拓展了包外子类的可见性
  - 由于 protected 向其他的包开了一道口子，可能会被恶意利用，所以一般来说不要用
  - protected 最好用于 abstract 方法，这样 protected 的作用，就相当于只是突破包访问的限制，而不会产生其他副作用
- public：对所有类可见

类及其组成要素能用的访问权限
- 类：top level 的类不能是 private，其他都可以
- 方法 & 属性：
- main：只能是 public
- 构造函数：

最佳实践是：尽可能使用最小权限


### 抽象类

- 抽象类的设计，是为了实现这样一种效果：某些位于上层的类由于太抽象，它们不应该被实例化，而应该被视为一种约束，要求子类必须实现某种动作
- abstract 不能用于属性字段
- 只要含有一个抽象方法，该类就必须是抽象类，继承抽象类的子类如果没有实现抽象方法，也必须声明为抽象类
- 因为抽象类不能被实例化，这种机制保证了抽象方法必须被子类实现，否则子类就没法被使用

> 非正式的讲，抽象类是一种半残的类


### 枚举类

### 接口

- 接口只有定义，没有实现。只能有方法的定义，不能有字段的定义，可以有常量
  - 可以提供一种兜底的默认实现，以减轻实现类的编码量，另一个重要用途是解决兼容的问题
- 接口的所有方法，默认都是 public，限定访问是没有意义的，因为接口不关心具体实现，也就不关心访问的限制或隔离
  - 尽管也能定义静态方法和私有方法，但这些长尾特性使用场景很有限
- 对于普通类，接口的所有方法都必须被实现，抽象类则不需要
- 一个类可以 implement 多个接口
- 接口可以被视为一种【类型】，定义变量时可以用接口声明其类型
- 接口之间也可以继承
- 接口的好处：Java 不允许多重继承，以减小复杂度，但接口提供了一种弥补


### lambda 表达式

- 带参数的表达式
  - 参数 -> 单个表达式
  - 参数 -> { 多个表达式 }
- 使用场景
  - 实现只有一个方法的接口


### 编译器寻找类的规则

大致顺序如下：
- Java API 所在目录
- class path 指定的目录
  - 可以执行多个目录，编译器会按顺序找
  - `.` 号表示当前目录，如果没有显式定义 class path，那么 `.` 就是默认 class path
  - 如果显式的定义了 class path，需要手动添加 `.`，否则当前目录就不在 class path 中
